<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mighty Raffle Bot</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; background: white; border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 32px; margin-bottom: 8px; }
        .main { padding: 30px; }
        .tab-container { display: flex; gap: 10px; margin-bottom: 25px; border-bottom: 2px solid #e0e0e0; }
        .tab { padding: 10px 20px; cursor: pointer; background: transparent; border: none; font-size: 15px; font-weight: 600; color: #666; border-bottom: 3px solid transparent; }
        .tab.active { color: #667eea; border-bottom-color: #667eea; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .card { background: #f8f9fa; border-radius: 10px; padding: 20px; margin-bottom: 20px; border: 1px solid #e0e0e0; }
        .card h3 { margin-bottom: 15px; color: #333; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 6px; font-weight: 600; color: #333; }
        .form-group input, .form-group textarea, .form-group select { width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; }
        .form-group textarea { resize: vertical; min-height: 100px; font-family: monospace; }
        .btn { padding: 10px 24px; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer; margin-right: 10px; margin-bottom: 10px; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .log-container { background: #1e1e1e; color: #d4d4d4; padding: 15px; border-radius: 6px; font-family: monospace; font-size: 12px; max-height: 350px; overflow-y: auto; }
        .log-entry { margin-bottom: 6px; }
        .log-entry.success { color: #4caf50; }
        .log-entry.error { color: #f44336; }
        .log-entry.warning { color: #ff9800; }
        .log-entry.info { color: #2196f3; }
        .account-list { list-style: none; }
        .account-item { background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border: 1px solid #e0e0e0; }
        .account-status { padding: 4px 10px; border-radius: 4px; font-size: 11px; font-weight: 600; }
        .account-status.logged-in { background: #d4edda; color: #155724; }
        .account-status.pending { background: #fff3cd; color: #856404; }
        .account-status.failed { background: #f8d7da; color: #721c24; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 25px; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; text-align: center; }
        .stat-value { font-size: 32px; font-weight: bold; }
        .stat-label { font-size: 13px; opacity: 0.9; }
        .progress-bar { width: 100%; height: 8px; background: #e0e0e0; border-radius: 4px; overflow: hidden; margin-top: 15px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s; }
        .alert { padding: 12px 16px; border-radius: 6px; margin-bottom: 15px; }
        .alert-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .alert-warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .spinner { display: inline-block; width: 16px; height: 16px; border: 3px solid rgba(102,126,234,0.3); border-radius: 50%; border-top-color: #667eea; animation: spin 1s linear infinite; vertical-align: middle; margin-right: 6px; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .helper-text { font-size: 12px; color: #666; margin-top: 4px; }
        .raffle-table { width: 100%; border-collapse: collapse; background: white; border-radius: 6px; overflow: hidden; }
        .raffle-table th { background: #667eea; color: white; padding: 12px; text-align: left; font-weight: 600; }
        .raffle-table td { padding: 12px; border-bottom: 1px solid #e0e0e0; }
        .raffle-table tr:last-child td { border-bottom: none; }
        .raffle-table tr:hover { background: #f8f9fa; }
        .status-badge { padding: 4px 10px; border-radius: 4px; font-size: 11px; font-weight: 600; display: inline-block; }
        .status-active { background: #d4edda; color: #155724; }
        .status-disabled { background: #f8d7da; color: #721c24; }
        .mode-selector { display: flex; gap: 10px; align-items: center; margin-bottom: 15px; }
        .radio-group { display: flex; gap: 20px; }
        .radio-label { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .radio-label input[type="radio"] { cursor: pointer; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Mighty Raffle Bot</h1>
            <p>Local Server Edition - Concurrent Mode</p>
        </div>
        
        <div class="main">
            <div class="tab-container">
                <button class="tab active" onclick="switchTab('setup')">‚öôÔ∏è Setup</button>
                <button class="tab" onclick="switchTab('accounts')">üë• Accounts</button>
                <button class="tab" onclick="switchTab('raffles')">üé´ Raffles</button>
                <button class="tab" onclick="switchTab('draw')">üé≤ Draw</button>
                <button class="tab" onclick="switchTab('results')">üìä Results</button>
            </div>

            <!-- SETUP TAB -->
            <div id="setup" class="tab-content active">
                <div class="card">
                    <h3>üìù Add Accounts</h3>
                    <div class="form-group">
                        <label>Credentials (username:password per line)</label>
                        <textarea id="accountsInput" placeholder="username1:password1&#10;username2:password2"></textarea>
                    </div>
                    <button class="btn btn-primary" onclick="addAccounts()">‚ûï Add</button>
                    <button class="btn btn-secondary" onclick="clearAccounts()">üóëÔ∏è Clear</button>
                </div>
            </div>

            <!-- ACCOUNTS TAB -->
            <div id="accounts" class="tab-content">
                <div class="card">
                    <h3>üë• Accounts (<span id="accountCount">0</span>)</h3>
                    <button class="btn btn-primary" onclick="loginAll()" id="loginBtn">üîê Login All</button>
                    <button class="btn btn-success" onclick="checkPoints()">üí∞ Check Points</button>
                    <div id="accountsList" style="margin-top: 15px;"></div>
                </div>
                
                <div class="card">
                    <h3>üìã Logs</h3>
                    <div class="log-container" id="loginLogs">
                        <div class="log-entry info">Ready...</div>
                    </div>
                </div>
            </div>

            <!-- RAFFLES TAB -->
            <div id="raffles" class="tab-content">
                <div class="card">
                    <h3>üé´ Available Raffles</h3>
                    <button class="btn btn-primary" onclick="fetchRaffles()" id="fetchRafflesBtn">üîÑ Refresh</button>
                    <div id="rafflesContainer" style="margin-top: 15px;">
                        <p style="text-align:center;color:#666;padding:20px;">Click "Refresh" to load raffles</p>
                    </div>
                </div>
            </div>

            <!-- DRAW TAB -->
            <div id="draw" class="tab-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalAccounts">0</div>
                        <div class="stat-label">Accounts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="loggedInCount">0</div>
                        <div class="stat-label">Logged In</div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üé≤ Execute Draws</h3>
                    
                    <div class="mode-selector">
                        <label style="font-weight: 600; color: #333;">Draw Mode:</label>
                        <div class="radio-group">
                            <label class="radio-label">
                                <input type="radio" name="drawMode" value="sequential" checked>
                                <span>Sequential (Slower, Safer)</span>
                            </label>
                            <label class="radio-label">
                                <input type="radio" name="drawMode" value="concurrent">
                                <span>Concurrent (Faster, Multiple at once)</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Raffle ID</label>
                        <input type="text" id="raffleId" placeholder="Enter raffle ID">
                        <div class="helper-text">Get this from the Raffles tab</div>
                    </div>
                    
                    <div class="form-group">
                        <label>Attempts per Account</label>
                        <input type="number" id="attemptCount" value="1" min="1" max="100">
                        <div class="helper-text">Each account will try this many times</div>
                    </div>
                    
                    <div class="form-group" id="concurrentWorkersGroup">
                        <label>Concurrent Workers (1-10)</label>
                        <input type="number" id="concurrentWorkers" value="3" min="1" max="10">
                        <div class="helper-text">Number of accounts processing simultaneously</div>
                    </div>
                    
                    <button class="btn btn-primary" onclick="startDraw()" id="drawBtn">‚ñ∂Ô∏è Start Draw</button>
                    <button class="btn btn-danger" onclick="stopDraw()" id="stopBtn" style="display:none;">‚èπÔ∏è Stop</button>
                    <button class="btn btn-secondary" onclick="clearDrawLogs()">üóëÔ∏è Clear Logs</button>
                    
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div style="text-align:center;margin-top:8px;font-size:13px;color:#666;">
                        <span id="progressText">0 / 0</span>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üìã Draw Logs</h3>
                    <div class="log-container" id="drawLogs">
                        <div class="log-entry info">Ready...</div>
                    </div>
                </div>
            </div>

            <!-- RESULTS TAB -->
            <div id="results" class="tab-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalDraws">0</div>
                        <div class="stat-label">Total Draws</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">
                        <div class="stat-value" id="successDraws">0</div>
                        <div class="stat-label">Successful</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #dc3545 0%, #e83e8c 100%);">
                        <div class="stat-value" id="failDraws">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #ff9800 0%, #ffb74d 100%);">
                        <div class="stat-value" id="rateLimitDraws">0</div>
                        <div class="stat-label">Rate Limited</div>
                    </div>
                </div>
                
                <div class="card">
                    <h3>üìä Session Summary</h3>
                    <p style="color:#666;font-size:14px;">Results from the last draw session will appear here.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Change this to your deployed server URL
        // For local: 'http://localhost:3001/api'
        // For deployed: 'https://your-app.up.railway.app/api'
        const API = window.location.hostname === 'localhost' 
            ? 'http://localhost:3001/api' 
            : `${window.location.protocol}//${window.location.host}/api`;
        
        const state = {
            accounts: [],
            raffles: [],
            isDrawing: false,
            results: { total: 0, success: 0, fail: 0, rateLimit: 0 }
        };

        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tab).classList.add('active');
            
            // Show/hide concurrent workers based on mode
            if (tab === 'draw') {
                updateConcurrentWorkersVisibility();
            }
        }

        function updateConcurrentWorkersVisibility() {
            const mode = document.querySelector('input[name="drawMode"]:checked').value;
            const workersGroup = document.getElementById('concurrentWorkersGroup');
            workersGroup.style.display = mode === 'concurrent' ? 'block' : 'none';
        }

        // Add event listeners for radio buttons
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('input[name="drawMode"]').forEach(radio => {
                radio.addEventListener('change', updateConcurrentWorkersVisibility);
            });
        });

        function addAccounts() {
            const txt = document.getElementById('accountsInput').value.trim();
            if (!txt) return alert('Please enter credentials');
            
            const lines = txt.split('\n').filter(l => l.trim());
            for (const line of lines) {
                const [username, password] = line.split(':').map(s => s.trim());
                if (!username || !password) continue;
                if (state.accounts.find(a => a.username === username)) continue;
                state.accounts.push({ username, password, token: null, status: 'pending', points: null });
            }
            
            updateUI();
            document.getElementById('accountsInput').value = '';
            alert(`Added ${lines.length} account(s)`);
        }

        function clearAccounts() {
            if (!confirm('Clear all accounts?')) return;
            state.accounts = [];
            updateUI();
        }

        function updateAccountsList() {
            const el = document.getElementById('accountsList');
            if (state.accounts.length === 0) {
                el.innerHTML = '<p style="text-align:center;color:#666;">No accounts added</p>';
                return;
            }
            
            let html = '<ul class="account-list">';
            for (const acc of state.accounts) {
                const statusClass = acc.status === 'logged-in' ? 'logged-in' : acc.status === 'failed' ? 'failed' : 'pending';
                const pointsText = acc.points !== null ? ` | üí∞ ${acc.points} pts` : '';
                html += `
                    <li class="account-item">
                        <span><strong>${acc.username}</strong>${pointsText}</span>
                        <span class="account-status ${statusClass}">${acc.status}</span>
                    </li>
                `;
            }
            html += '</ul>';
            el.innerHTML = html;
        }

        async function loginAll() {
            if (state.accounts.length === 0) return alert('No accounts to login');
            
            const btn = document.getElementById('loginBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Logging in...';
            
            clearLogs('loginLogs');
            addLog('loginLogs', 'Starting login process...', 'info');
            
            for (const acc of state.accounts) {
                try {
                    addLog('loginLogs', `[${acc.username}] Getting Turnstile token...`, 'info');
                    
                    // Get Turnstile token first
                    const turnstileRes = await fetch(`${API}/turnstile`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    
                    if (!turnstileRes.ok) {
                        throw new Error(`Turnstile failed: ${turnstileRes.status}`);
                    }
                    
                    const turnstileData = await turnstileRes.json();
                    
                    if (!turnstileData.success || !turnstileData.token) {
                        throw new Error(turnstileData.error || 'Turnstile solve failed');
                    }
                    
                    addLog('loginLogs', `[${acc.username}] Logging in...`, 'info');
                    
                    // Now login with Turnstile token
                    const res = await fetch(`${API}/login`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            username: acc.username, 
                            password: acc.password,
                            turnstileToken: turnstileData.token
                        })
                    });
                    
                    const data = await res.json();
                    
                    if (data.success && data.token) {
                        acc.token = data.token;
                        acc.status = 'logged-in';
                        addLog('loginLogs', `‚úì ${acc.username}: Login successful!`, 'success');
                    } else {
                        acc.status = 'failed';
                        const errorMsg = data.message || data.error || 'Login failed';
                        addLog('loginLogs', `‚úó ${acc.username}: ${errorMsg}`, 'error');
                    }
                    
                } catch (e) {
                    acc.status = 'failed';
                    addLog('loginLogs', `‚úó ${acc.username}: ${e.message}`, 'error');
                }
                
                updateUI();
                await sleep(2000); // Wait between accounts
            }
            
            addLog('loginLogs', 'Login process complete!', 'success');
            btn.disabled = false;
            btn.innerHTML = 'üîê Login All';
        }

        async function checkPoints() {
            const loggedIn = state.accounts.filter(a => a.status === 'logged-in');
            if (loggedIn.length === 0) return alert('No logged in accounts');
            
            clearLogs('loginLogs');
            addLog('loginLogs', 'Checking points...', 'info');
            
            for (const acc of loggedIn) {
                try {
                    const res = await fetch(`${API}/check-points`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ token: acc.token })
                    });
                    
                    const data = await res.json();
                    if (data.success) {
                        acc.points = data.points;
                        addLog('loginLogs', `${acc.username}: ${data.points} points`, 'success');
                    } else {
                        addLog('loginLogs', `${acc.username}: ${data.message}`, 'error');
                    }
                } catch (e) {
                    addLog('loginLogs', `${acc.username}: ${e.message}`, 'error');
                }
                
                updateUI();
                await sleep(500);
            }
        }

        async function fetchRaffles() {
            const btn = document.getElementById('fetchRafflesBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span>Loading...';
            
            try {
                const res = await fetch(`${API}/raffles`);
                const data = await res.json();
                
                if (data.success && data.raffles) {
                    state.raffles = data.raffles;
                    displayRaffles();
                } else {
                    alert('Failed to fetch raffles');
                }
            } catch (e) {
                alert('Error: ' + e.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'üîÑ Refresh';
            }
        }

        function displayRaffles() {
            const el = document.getElementById('rafflesContainer');
            if (state.raffles.length === 0) {
                el.innerHTML = '<p style="text-align:center;color:#666;padding:20px;">No raffles found</p>';
                return;
            }
            
            let html = '<table class="raffle-table"><thead><tr><th>Raffle ID</th><th>Title</th><th>Cost</th><th>Status</th></tr></thead><tbody>';
            for (const r of state.raffles) {
                const statusClass = r.status === 'active' ? 'status-active' : 'status-disabled';
                html += `
                    <tr onclick="selectRaffle('${r.id}')">
                        <td><code>${r.id}</code></td>
                        <td>${r.title || 'Unknown'}</td>
                        <td>${r.cost || 'N/A'} ü™ô</td>
                        <td><span class="status-badge ${statusClass}">${r.status}</span></td>
                    </tr>
                `;
            }
            html += '</tbody></table>';
            el.innerHTML = html;
        }

        function selectRaffle(id) {
            document.getElementById('raffleId').value = id;
            switchTab('draw');
            document.querySelector('.tab[onclick*="draw"]').click();
        }

        async function startDraw() {
            const raffleId = document.getElementById('raffleId').value.trim();
            const attempts = parseInt(document.getElementById('attemptCount').value) || 1;
            const mode = document.querySelector('input[name="drawMode"]:checked').value;
            
            if (!raffleId) return alert('Enter a Raffle ID');
            
            const loggedIn = state.accounts.filter(a => a.status === 'logged-in');
            if (loggedIn.length === 0) return alert('No logged in accounts');
            
            state.isDrawing = true;
            state.results = { total: 0, success: 0, fail: 0, rateLimit: 0 };
            
            document.getElementById('drawBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'inline-block';
            
            clearLogs('drawLogs');
            addLog('drawLogs', `Mode: ${mode.toUpperCase()}`, 'info');
            addLog('drawLogs', `Raffle: ${raffleId}`, 'info');
            addLog('drawLogs', `Accounts: ${loggedIn.length}`, 'info');
            addLog('drawLogs', `Attempts: ${attempts}`, 'info');
            addLog('drawLogs', '='.repeat(40), 'info');
            
            if (mode === 'concurrent') {
                await drawConcurrent(raffleId, attempts, loggedIn);
            } else {
                await drawSequential(raffleId, attempts, loggedIn);
            }
        }

        async function drawSequential(raffleId, attempts, accounts) {
            const total = accounts.length * attempts;
            let completed = 0;
            
            for (const account of accounts) {
                if (!state.isDrawing) break;
                
                // Check if account should skip (insufficient coins from previous attempt)
                if (account.skipRemainingAttempts) {
                    completed += attempts;
                    updateProgress(completed, total);
                    continue;
                }
                
                for (let i = 1; i <= attempts; i++) {
                    if (!state.isDrawing) break;
                    
                    const logPrefix = `[${account.username}] Attempt ${i}/${attempts}`;
                    addLog('drawLogs', `${logPrefix}: Solving Turnstile...`, 'info');
                    
                    try {
                        // IMPORTANT: Get fresh Turnstile token for EACH draw (like Go version)
                        const tRes = await fetch(`${API}/turnstile`, { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' } 
                        });
                        
                        if (!tRes.ok) {
                            throw new Error(`Turnstile failed: ${tRes.status}`);
                        }
                        
                        const tData = await tRes.json();
                        if (!tData.success) throw new Error('Turnstile solve failed');
                        
                        addLog('drawLogs', `${logPrefix}: Executing draw...`, 'info');
                        
                        // Add jitter (0-2 seconds like Go version)
                        await sleep(Math.random() * 2000);
                        
                        const dRes = await fetch(`${API}/draw`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                token: account.token, 
                                raffleId, 
                                turnstileToken: tData.token  // Fresh token for each attempt!
                            })
                        });
                        const dData = await dRes.json();
                        
                        state.results.total++;
                        completed++;
                        
                        if (dData.success) {
                            state.results.success++;
                            addLog('drawLogs', `${logPrefix}: ‚úì ${dData.message}`, 'success');
                        } else if (dData.isRateLimit) {
                            state.results.rateLimit++;
                            addLog('drawLogs', `${logPrefix}: ‚ö† Rate limited! Waiting 20s...`, 'warning');
                            await sleep(20000);
                            i--; // Retry this attempt
                            completed--;
                            state.results.total--;
                            continue;
                        } else if (dData.message && dData.message.toLowerCase().includes('insufficient coins')) {
                            state.results.fail++;
                            addLog('drawLogs', `${logPrefix}: ‚ö† Insufficient coins - Skipping remaining attempts`, 'warning');
                            account.skipRemainingAttempts = true;
                            completed += (attempts - i);
                            break;
                        } else {
                            state.results.fail++;
                            addLog('drawLogs', `${logPrefix}: ‚úó ${dData.message}`, 'error');
                        }
                        
                        updateProgress(completed, total);
                        updateResults();
                        
                        // Wait between attempts (6-8 seconds like Go version)
                        if (i < attempts) {
                            const waitTime = 6000 + Math.random() * 2000;
                            addLog('drawLogs', `${logPrefix}: Waiting ${(waitTime/1000).toFixed(1)}s...`, 'info');
                            await sleep(waitTime);
                        }
                        
                    } catch (e) {
                        state.results.fail++;
                        state.results.total++;
                        completed++;
                        addLog('drawLogs', `${logPrefix}: ‚úó ${e.message}`, 'error');
                        updateProgress(completed, total);
                        updateResults();
                    }
                }
                
                // Wait between accounts (4-7 seconds like Go version)
                if (state.isDrawing && account !== accounts[accounts.length - 1]) {
                    const waitTime = 4000 + Math.random() * 3000;
                    await sleep(waitTime);
                }
            }
            
            finishDrawing();
        }

        async function drawConcurrent(raffleId, attempts, accounts) {
            const workers = parseInt(document.getElementById('concurrentWorkers').value) || 3;
            const total = accounts.length * attempts;
            let completed = 0;
            
            // Create task queue
            const tasks = [];
            for (const account of accounts) {
                for (let i = 1; i <= attempts; i++) {
                    tasks.push({ account, attempt: i, total: attempts });
                }
            }
            
            addLog('drawLogs', `Using ${workers} concurrent workers`, 'info');
            
            // Process task
            const processTask = async (task) => {
                if (!state.isDrawing) return;
                
                const { account, attempt, total } = task;
                const logPrefix = `[${account.username}] Attempt ${attempt}/${total}`;
                
                addLog('drawLogs', `${logPrefix}: Processing...`, 'info');
                
                try {
                    const tRes = await fetch(`${API}/turnstile`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' } 
                    });
                    const tData = await tRes.json();
                    if (!tData.success) throw new Error('Solve failed');
                    
                    // Add jitter
                    await sleep(Math.random() * 2000);
                    
                    const dRes = await fetch(`${API}/draw`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            token: account.token, 
                            raffleId, 
                            turnstileToken: tData.token 
                        })
                    });
                    const dData = await dRes.json();
                    
                    state.results.total++;
                    completed++;
                    
                    if (dData.success) {
                        state.results.success++;
                        addLog('drawLogs', `${logPrefix}: ‚úì ${dData.message}`, 'success');
                    } else if (dData.isRateLimit) {
                        state.results.rateLimit++;
                        addLog('drawLogs', `${logPrefix}: ‚ö† Rate limited! Waiting 20s...`, 'warning');
                        await sleep(20000);
                        // Re-queue this task
                        return processTask(task);
                    } else if (dData.message && dData.message.toLowerCase().includes('insufficient coins')) {
                        state.results.fail++;
                        addLog('drawLogs', `${logPrefix}: ‚ö† Insufficient coins - Skipping remaining attempts`, 'warning');
                        // Mark account to skip
                        account.skipRemainingAttempts = true;
                        // Remove all remaining tasks for this account
                        for (let i = tasks.length - 1; i >= 0; i--) {
                            if (tasks[i].account.username === account.username) {
                                tasks.splice(i, 1);
                                completed++;
                            }
                        }
                    } else {
                        state.results.fail++;
                        addLog('drawLogs', `${logPrefix}: ‚úó ${dData.message}`, 'error');
                    }
                    
                    updateProgress(completed, total);
                    updateResults();
                    
                    // Wait between attempts
                    await sleep(6000 + Math.random() * 2000);
                    
                } catch (e) {
                    state.results.fail++;
                    state.results.total++;
                    completed++;
                    addLog('drawLogs', `${logPrefix}: ‚úó ${e.message}`, 'error');
                    updateProgress(completed, total);
                    updateResults();
                }
            };
            
            // Process tasks with concurrency limit
            const processBatch = async () => {
                const batch = [];
                for (let i = 0; i < Math.min(workers, tasks.length); i++) {
                    const task = tasks.shift();
                    if (task) {
                        batch.push(processTask(task));
                    }
                }
                
                if (batch.length > 0) {
                    await Promise.all(batch);
                }
                
                if (tasks.length > 0 && state.isDrawing) {
                    return processBatch();
                }
            };
            
            await processBatch();
            
            finishDrawing();
        }

        function finishDrawing() {
            addLog('drawLogs', '\n========== SUMMARY ==========', 'info');
            addLog('drawLogs', `Total: ${state.results.total}`, 'info');
            addLog('drawLogs', `Success: ${state.results.success}`, 'success');
            addLog('drawLogs', `Failed: ${state.results.fail}`, 'error');
            addLog('drawLogs', `Rate Limited: ${state.results.rateLimit}`, 'warning');
            
            state.isDrawing = false;
            document.getElementById('drawBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'none';
            updateResults();
            switchTab('results');
        }

        function stopDraw() {
            state.isDrawing = false;
            addLog('drawLogs', '\n[!] Stopping...', 'warning');
        }

        function clearDrawLogs() {
            clearLogs('drawLogs');
            addLog('drawLogs', 'Ready...', 'info');
        }

        function updateProgress(curr, tot) {
            const pct = (curr / tot) * 100;
            document.getElementById('progressFill').style.width = pct + '%';
            document.getElementById('progressText').textContent = `${curr} / ${tot}`;
        }

        function updateResults() {
            document.getElementById('totalDraws').textContent = state.results.total;
            document.getElementById('successDraws').textContent = state.results.success;
            document.getElementById('failDraws').textContent = state.results.fail;
            document.getElementById('rateLimitDraws').textContent = state.results.rateLimit;
        }

        function updateUI() {
            document.getElementById('accountCount').textContent = state.accounts.length;
            document.getElementById('totalAccounts').textContent = state.accounts.length;
            document.getElementById('loggedInCount').textContent = state.accounts.filter(a => a.status === 'logged-in').length;
            updateAccountsList();
        }

        function addLog(id, msg, type = 'info') {
            const el = document.getElementById(id);
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.textContent = msg;
            el.appendChild(div);
            el.scrollTop = el.scrollHeight;
        }

        function clearLogs(id) {
            document.getElementById(id).innerHTML = '';
        }

        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        updateUI();
    </script>
</body>
</html>
